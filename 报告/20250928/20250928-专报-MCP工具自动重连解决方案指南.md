# MCP工具自动重连解决方案指南

## 📋 问题分析

### 🔍 MCP工具掉线常见原因
- **网络超时**：长时间无活动导致连接超时
- **认证过期**：API Token或认证信息过期
- **服务端限制**：请求频率过高被限流
- **网络波动**：网络不稳定导致连接中断
- **内存泄漏**：长期运行导致客户端内存问题

## 🛠️ 解决方案

### 方案一：Cursor IDE配置优化

#### 1. MCP配置文件优化
在Cursor的设置中找到MCP配置文件（通常在 `.cursor/mcp_settings.json`），添加重连参数：

```json
{
  "mcpServers": {
    "yingmi_mcp": {
      "command": "...",
      "args": [...],
      "reconnection": {
        "enabled": true,
        "maxRetries": 5,
        "retryDelay": 2000,
        "exponentialBackoff": true,
        "maxRetryDelay": 30000
      },
      "keepAlive": {
        "enabled": true,
        "interval": 30000,
        "timeout": 10000
      }
    },
    "search_caixin_content": {
      "command": "...",
      "args": [...],
      "reconnection": {
        "enabled": true,
        "maxRetries": 5,
        "retryDelay": 2000,
        "exponentialBackoff": true
      }
    },
    "Tavily_MCP_Server": {
      "command": "...",
      "args": [...],
      "reconnection": {
        "enabled": true,
        "maxRetries": 5,
        "retryDelay": 2000,
        "exponentialBackoff": true
      }
    }
  }
}
```

### 方案二：PowerShell监控脚本（推荐）

创建自动监控和重连脚本：

```powershell
# MCP工具监控和自动重连脚本
# 保存为: MCP_AutoReconnect.ps1

param(
    [int]$CheckInterval = 30,  # 检查间隔（秒）
    [int]$MaxRetries = 3       # 最大重试次数
)

# MCP工具进程名称（需要根据实际情况调整）
$MCPProcesses = @(
    "yingmi_mcp",
    "caixin_mcp", 
    "tavily_mcp"
)

# 日志函数
function Write-Log {
    param([string]$Message)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    Write-Output "[$timestamp] $Message"
    Add-Content -Path "MCP_Monitor.log" -Value "[$timestamp] $Message"
}

# 检查MCP服务状态
function Test-MCPService {
    param([string]$ServiceName)
    
    try {
        # 这里需要根据实际情况调整检查逻辑
        # 可以通过检查进程、端口或API响应来判断
        $process = Get-Process -Name $ServiceName -ErrorAction SilentlyContinue
        return $process -ne $null
    }
    catch {
        return $false
    }
}

# 重启MCP服务
function Restart-MCPService {
    param([string]$ServiceName)
    
    Write-Log "正在重启 $ServiceName..."
    
    try {
        # 停止现有进程
        Stop-Process -Name $ServiceName -Force -ErrorAction SilentlyContinue
        Start-Sleep -Seconds 5
        
        # 重启服务（需要根据实际启动命令调整）
        switch ($ServiceName) {
            "yingmi_mcp" {
                Start-Process -FilePath "python" -ArgumentList "-m", "yingmi_mcp" -WindowStyle Hidden
            }
            "caixin_mcp" {
                Start-Process -FilePath "python" -ArgumentList "-m", "caixin_mcp" -WindowStyle Hidden
            }
            "tavily_mcp" {
                Start-Process -FilePath "python" -ArgumentList "-m", "tavily_mcp" -WindowStyle Hidden
            }
        }
        
        Start-Sleep -Seconds 10
        Write-Log "$ServiceName 重启完成"
        return $true
    }
    catch {
        Write-Log "重启 $ServiceName 失败: $($_.Exception.Message)"
        return $false
    }
}

# 主监控循环
Write-Log "MCP监控服务启动"

while ($true) {
    foreach ($service in $MCPProcesses) {
        if (-not (Test-MCPService -ServiceName $service)) {
            Write-Log "检测到 $service 离线，开始重连..."
            
            $retryCount = 0
            $success = $false
            
            while ($retryCount -lt $MaxRetries -and -not $success) {
                $retryCount++
                Write-Log "第 $retryCount 次尝试重连 $service..."
                
                if (Restart-MCPService -ServiceName $service) {
                    Start-Sleep -Seconds 15
                    if (Test-MCPService -ServiceName $service) {
                        Write-Log "$service 重连成功！"
                        $success = $true
                    }
                }
                
                if (-not $success -and $retryCount -lt $MaxRetries) {
                    Start-Sleep -Seconds 30
                }
            }
            
            if (-not $success) {
                Write-Log "$service 重连失败，已达到最大重试次数"
            }
        }
    }
    
    Start-Sleep -Seconds $CheckInterval
}
```

### 方案三：批处理文件自动重连

创建简单的批处理重连脚本：

```batch
@echo off
REM 保存为: MCP_AutoStart.bat

:LOOP
echo %date% %time% - 检查MCP工具状态...

REM 检查并重启yingmi MCP
tasklist | find "yingmi_mcp" >nul
if errorlevel 1 (
    echo %date% %time% - yingmi_mcp离线，正在重启...
    start /B python -m yingmi_mcp
    timeout /t 10
)

REM 检查并重启caixin MCP
tasklist | find "caixin_mcp" >nul
if errorlevel 1 (
    echo %date% %time% - caixin_mcp离线，正在重启...
    start /B python -m caixin_mcp
    timeout /t 10
)

REM 检查并重启Tavily MCP
tasklist | find "tavily_mcp" >nul
if errorlevel 1 (
    echo %date% %time% - tavily_mcp离线，正在重启...
    start /B python -m tavily_mcp
    timeout /t 10
)

echo %date% %time% - 检查完成，等待30秒...
timeout /t 30
goto LOOP
```

### 方案四：Python监控脚本

创建更智能的Python监控脚本：

```python
# 保存为: mcp_monitor.py
import time
import subprocess
import requests
import logging
from datetime import datetime
import psutil
import os

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mcp_monitor.log'),
        logging.StreamHandler()
    ]
)

class MCPMonitor:
    def __init__(self):
        self.services = {
            'yingmi_mcp': {
                'process_name': 'yingmi_mcp',
                'start_command': ['python', '-m', 'yingmi_mcp'],
                'health_check_url': None,  # 如果有健康检查URL
                'max_retries': 3,
                'retry_delay': 30
            },
            'caixin_mcp': {
                'process_name': 'caixin_mcp', 
                'start_command': ['python', '-m', 'caixin_mcp'],
                'health_check_url': None,
                'max_retries': 3,
                'retry_delay': 30
            },
            'tavily_mcp': {
                'process_name': 'tavily_mcp',
                'start_command': ['python', '-m', 'tavily_mcp'], 
                'health_check_url': None,
                'max_retries': 3,
                'retry_delay': 30
            }
        }
        
    def is_process_running(self, process_name):
        """检查进程是否运行"""
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                if process_name.lower() in proc.info['name'].lower():
                    return True
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return False
        
    def health_check(self, service_name):
        """健康检查"""
        service = self.services[service_name]
        
        # 首先检查进程
        if not self.is_process_running(service['process_name']):
            return False
            
        # 如果有健康检查URL，进行HTTP检查
        if service.get('health_check_url'):
            try:
                response = requests.get(service['health_check_url'], timeout=10)
                return response.status_code == 200
            except:
                return False
                
        return True
        
    def start_service(self, service_name):
        """启动服务"""
        service = self.services[service_name]
        
        try:
            # 先杀死现有进程
            self.kill_service(service_name)
            time.sleep(5)
            
            # 启动新进程
            subprocess.Popen(
                service['start_command'],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            
            logging.info(f"已启动 {service_name}")
            return True
            
        except Exception as e:
            logging.error(f"启动 {service_name} 失败: {e}")
            return False
            
    def kill_service(self, service_name):
        """停止服务"""
        service = self.services[service_name]
        process_name = service['process_name']
        
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                if process_name.lower() in proc.info['name'].lower():
                    proc.terminate()
                    time.sleep(2)
                    if proc.is_running():
                        proc.kill()
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
                
    def monitor_service(self, service_name):
        """监控单个服务"""
        service = self.services[service_name]
        
        if not self.health_check(service_name):
            logging.warning(f"{service_name} 离线，开始重连...")
            
            for attempt in range(service['max_retries']):
                logging.info(f"第 {attempt + 1} 次尝试重启 {service_name}")
                
                if self.start_service(service_name):
                    time.sleep(15)  # 等待服务启动
                    
                    if self.health_check(service_name):
                        logging.info(f"{service_name} 重连成功！")
                        return True
                        
                if attempt < service['max_retries'] - 1:
                    time.sleep(service['retry_delay'])
                    
            logging.error(f"{service_name} 重连失败，已达到最大重试次数")
            return False
            
        return True
        
    def run(self, check_interval=30):
        """运行监控"""
        logging.info("MCP监控服务启动")
        
        while True:
            try:
                for service_name in self.services:
                    self.monitor_service(service_name)
                    
                time.sleep(check_interval)
                
            except KeyboardInterrupt:
                logging.info("监控服务停止")
                break
            except Exception as e:
                logging.error(f"监控服务异常: {e}")
                time.sleep(60)

if __name__ == "__main__":
    monitor = MCPMonitor()
    monitor.run()
```

## 📋 实施步骤

### 第一步：选择方案
- **简单需求**：使用批处理文件（方案三）
- **高级需求**：使用PowerShell脚本（方案二）
- **专业需求**：使用Python脚本（方案四）

### 第二步：部署脚本
1. 选择合适的脚本并保存到您的工作目录
2. 根据实际MCP工具的启动方式调整脚本参数
3. 测试脚本是否能正确检测和重启MCP工具

### 第三步：设置自动启动
- **Windows任务计划程序**：设置开机自动运行监控脚本
- **系统服务**：将监控脚本注册为Windows服务
- **快捷方式**：创建桌面快捷方式快速启动

### 第四步：优化网络环境
```cmd
REM 优化网络设置
netsh int tcp set global autotuninglevel=normal
netsh int tcp set global chimney=enabled
netsh int tcp set global rss=enabled
```

## ⚙️ 高级配置

### MCP工具启动参数优化
为每个MCP工具添加连接稳定性参数：

```bash
# yingmi MCP启动参数
python -m yingmi_mcp --timeout=60 --retry-count=5 --keep-alive=30

# caixin MCP启动参数  
python -m caixin_mcp --timeout=60 --retry-count=5 --keep-alive=30

# Tavily MCP启动参数
python -m tavily_mcp --timeout=60 --retry-count=5 --keep-alive=30
```

### 环境变量优化
设置环境变量提高连接稳定性：

```bash
SET MCP_CONNECTION_TIMEOUT=60
SET MCP_MAX_RETRIES=5
SET MCP_RETRY_DELAY=5
SET MCP_KEEP_ALIVE=30
```

## 🔍 监控和调试

### 日志分析
监控脚本会生成详细日志，通过日志分析连接问题：

```powershell
# 查看最近的连接问题
Get-Content MCP_Monitor.log | Select-String "离线|失败|错误" | Select-Object -Last 20
```

### 性能监控
```powershell
# 监控MCP工具资源使用
Get-Process | Where-Object {$_.ProcessName -like "*mcp*"} | Select-Object ProcessName, CPU, WorkingSet
```

## 📞 故障排除

### 常见问题及解决方案

1. **脚本无法检测到MCP进程**
   - 检查进程名称是否正确
   - 确认MCP工具是否正确安装

2. **重启失败**
   - 检查启动命令是否正确
   - 确认Python环境和依赖包

3. **权限问题**
   - 以管理员身份运行脚本
   - 检查文件和文件夹权限

4. **网络问题**
   - 检查防火墙设置
   - 确认代理配置

## 🚀 使用建议

1. **选择Python方案**：功能最全面，推荐专业用户使用
2. **设置合理的检查间隔**：建议30-60秒
3. **配置开机自启动**：确保系统重启后自动运行
4. **定期检查日志**：及时发现和解决问题
5. **备份重要配置**：避免配置丢失

---

## 🚨 重要免责声明

**本技术方案仅供参考，不保证100%解决所有连接问题**

### 风险提示
- 📈 **系统风险**：自动重连脚本可能影响系统性能
- 💰 **使用风险**：请在测试环境中充分验证后再部署到生产环境
- 📊 **兼容风险**：不同版本的MCP工具可能需要调整脚本参数
- ⚖️ **维护风险**：需要定期维护和更新脚本

### 技术声明
- 🏛️ **非官方方案**：本方案为第三方技术解决方案，非官方支持
- 📝 **使用责任**：用户需自行承担使用脚本的风险和责任
- 🔍 **测试建议**：建议在测试环境中充分测试后再正式使用
- ⏰ **更新提醒**：MCP工具更新后可能需要调整脚本参数

**技术有风险，使用需谨慎。本方案不对技术实施结果承担任何责任。**

---


